```tex
Unity version: 2020.3.14f1
```



# 原則 (Principles)

- **SRP (Single Responsibility Principle, 單一責任原則) :** 一個類應該只有一個改變的理由。
- **DIP (Dependency Inversion Principle, 依賴倒轉原則) :**  不要依賴實現，要依賴接口。
  - **(Hollywood Principle, 好萊塢原則) :** **上層模塊**儘量不要輪詢**下層模塊**。而是使用通知的形式。

- **OCP (Open-Closed Principle, 開放關閉原則) :**  對擴展開放，對修改關閉。
- **LKP/LOD (Least Knowledge Principle/Law of Demeter, 最少知識原則/迪米特原則) :** 只和自己直接有關系的"朋友"交談。
- **ISP (Inteface Segregation Principle, 接口隔離原則) :** 
- **LSP (Liskov Substitution Principle, 里氏替換原則) :** 



# 設計模式 (Design Patterns)

## 工廠模式 (Factory)

- 簡單工廠 (Simple Factory)
- 工廠方法 (Factory Method)
- 抽象工廠 (Abstract Factory)



## 單例模式 (Singleton)

> 確保一個類只有一個實例，並提供一個全局訪問點。

### 單例類 vs. 靜態類

單例類實實在在的是一個"實例"，可以作為參數傳遞。"實例"是在OOP中操作的重要的對象之一，它遵守OOP思想。也就是說，單例類可以「繼承」，有「多態」的特性，能夠「封裝」起來。



### 單例類的創建方式

- 直接在變量中初始化

- 延遲加載 (Lazy Loading)

- 加鎖解決延遲加載的多線程的重覆創建問題
  - 單鎖
  - 多重檢測鎖 (double checked locking)

- 靜態內部類
- .NET Framework 4+中的Lazy<T>，可以實現延遲加載，並且解決多線程的重覆創建問題



## 策略模式 (Strategy)



## 裝飾者模式 (Decorate)



## 觀察者模式 (Observer)



### 事件與委託 (event & delegate)



## 模板模式 (Template)

> 在一個方式中定義一個算法的骨架，而將一些步驟延遲到了子類中。模板方式使得子類可以在不改變算法結構的情況下，重新定義算法中的某些步驟。

是OOP中的繼承的其中一種用法。將一套算法中的具體實現延遲到子類中，這樣做的好處是可以使一套算法可以有多種不同的版本。



## 外觀模式 (Facade)

> 提供了一個統一的接口，用來訪問子系統中的一群接口。外觀定義了一個高層接口，讓子系統更容易使用。

簡單地來說，可以為一些常用的功能創建一個接口(例如: 游戲開始時會創建關卡、播放音樂、啟動各種的判斷器等)。這樣一來，用戶就不需要與多種類交互，達到解耦的目的。

但是，外觀類中的接口，有時候會變得異常龐大，使得維護難度提升。因此，這種模式應該只用於"常用"的功能中，而非一些只在一個地方使用的功能。



## 適配器模式 (Adapter)

> 將一個類的接口，轉換成客戶的期望的另一個接口。適配器讓原本接口不兼容的類可以合作無間。

相當於多了一個中間件，這一個中間件以"適配器"的身份，負責做兩邊的通信員。與**代理模式**類似。



## 命令模式 (Command)

> 將”請求”封裝成對象，以便使用不同的請求，隊列或者日志來參數化變化對象。命令模式支持可撤銷的操作。

與**策略模式**很像，但是策略模式封裝的是"行為"，而命令模式封裝的是"請求"。兩者有概念上的差別。且一般來說，命令都是以「隊列」的形式出現的，並且"請求"是能被撤銷的。



## 代理模式 (Proxy)

> 為另一個對象提供一個替身或占位符以控制對這個對象的認知。

與**適配器模式**一樣，也是作為一個中間件運作，但是他並不是只負責單一的對象，而是負責多個對象的中間件。能夠自由地切換到任意能代理的對象，令「使用者」與「具體對象」之間解除耦合。



## 橋接模式 (Bridge)

> 將抽象部分與它的實現部分分離，使它們都可以獨立地變化。

與**策略模式**很像，可以簡單地理解為"大"的策略模式。**策略模式**中，只考慮單個類中的變化，將其抽象成新的算法家族。而在**橋接模式**中，考慮的是多個類對應的多個變化。



